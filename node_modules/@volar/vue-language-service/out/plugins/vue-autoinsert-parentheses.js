"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const embedded = require("@volar/language-core");
const vue_language_core_1 = require("@volar/vue-language-core");
const vscode = require("vscode-languageserver-protocol");
const vue_autoinsert_dotvalue_1 = require("./vue-autoinsert-dotvalue");
const plugin = (context) => {
    if (!context?.typescript) {
        return {};
    }
    const ts = context.typescript.module;
    return {
        async provideAutoInsertionEdit(document, position, options_2) {
            const enabled = await context.configurationHost?.getConfiguration('vue.autoInsert.parentheses') ?? false;
            if (!enabled)
                return;
            if (!(0, vue_autoinsert_dotvalue_1.isCharacterTyping)(document, options_2))
                return;
            const [vueFile] = context.documents.getVirtualFileByUri(document.uri);
            if (!(vueFile instanceof vue_language_core_1.VueFile))
                return;
            let templateFormatScript;
            embedded.forEachEmbeddedFile(vueFile, embedded => {
                if (embedded.fileName.endsWith('.template_format.ts')) {
                    templateFormatScript = embedded;
                }
            });
            if (!templateFormatScript)
                return;
            const offset = document.offsetAt(position);
            for (const mappedRange of templateFormatScript.mappings) {
                if (mappedRange.sourceRange[1] === offset) {
                    const text = document.getText().substring(mappedRange.sourceRange[0], mappedRange.sourceRange[1]);
                    const ast = ts.createSourceFile(templateFormatScript.fileName, text, ts.ScriptTarget.Latest);
                    if (ast.statements.length === 1) {
                        const statement = ast.statements[0];
                        if (ts.isExpressionStatement(statement)
                            && ((ts.isAsExpression(statement.expression)
                                && ts.isTypeReferenceNode(statement.expression.type)
                                && ts.isIdentifier(statement.expression.type.typeName)
                                && statement.expression.type.typeName.text)
                                || (ts.isBinaryExpression(statement.expression)
                                    && statement.expression.right.getText(ast)
                                    && statement.expression.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword)
                                || (ts.isTypeOfExpression(statement.expression)
                                    && statement.expression.expression.getText(ast)))) {
                            // https://code.visualstudio.com/docs/editor/userdefinedsnippets#_grammar
                            const escapedText = text
                                .replaceAll('\\', '\\\\')
                                .replaceAll('$', '\\$')
                                .replaceAll('}', '\\}');
                            return vscode.TextEdit.replace({
                                start: document.positionAt(mappedRange.sourceRange[0]),
                                end: document.positionAt(mappedRange.sourceRange[1]),
                            }, '(' + escapedText + '$0' + ')');
                        }
                    }
                }
            }
        },
    };
};
exports.default = () => plugin;
//# sourceMappingURL=vue-autoinsert-parentheses.js.map